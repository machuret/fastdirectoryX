import type { NextApiRequest, NextApiResponse } from 'next';
import { getServerSession } from 'next-auth/next';
import { authOptions } from '@/pages/api/auth/[...nextauth]'; 
import prisma from '@/lib/prisma';
import { Prisma, ListingCategory, UserRole } from '@prisma/client'; 
import { Decimal } from '@prisma/client/runtime/library';
import slugify from 'slugify'; 
import { generateUniqueSlug } from '@/lib/utils'; 

/**
 * Interface representing the structure of review details within the Apify JSON data.
 */
interface JsonReviewDetail {
  /**
   * The name of the reviewer.
   */
  name?: string; 
  /**
   * The text content of the review.
   */
  text?: string; 
  /**
   * The rating given by the reviewer (out of 5).
   */
  stars?: number; 
  /**
   * The date the review was published.
   */
  publishedAtDate?: string; 
  /**
   * URLs of images associated with the review.
   */
  reviewImageUrls?: string[]; 
  /**
   * The response from the business owner, if any.
   */
  responseFromOwnerText?: string;
  /**
   * The date the business owner responded.
   */
  responseFromOwnerDate?: string; 
  /**
   * The URL of the review on the original platform.
   */
  reviewUrl?: string; 
  /**
   * The origin of the review (e.g., Google, Yelp).
   */
  reviewOrigin?: string; 
  // Add any other relevant fields from your JSON review structure
}

/**
 * Interface representing the structure of a single listing item from the Apify JSON data.
 * Contains various details about a business listing, including location, categories, reviews, and images.
 */
interface ApifyListingItem {
  /**
   * The title of the listing.
   */
  title?: string;
  /**
   * The price range of the business.
   */
  price?: string;
  /**
   * The name of the category the business belongs to.
   */
  categoryName?: string;
  /**
   * The address of the business.
   */
  address?: string;
  /**
   * The neighborhood the business is located in.
   */
  neighborhood?: string;
  /**
   * The street the business is located on.
   */
  street?: string;
  /**
   * The city the business is located in.
   */
  city?: string;
  /**
   * The postal code of the business.
   */
  postalCode?: string;
  /**
   * The state the business is located in.
   */
  state?: string;
  /**
   * The country code of the business.
   */
  countryCode?: string;
  /**
   * The phone number of the business.
   */
  phone?: string;
  /**
   * The location of the business (latitude and longitude).
   */
  location?: { lat?: number; lng?: number };
  /**
   * The total score of the business.
   */
  totalScore?: number;
  /**
   * Whether the business is permanently closed.
   */
  permanentlyClosed?: boolean;
  /**
   * Whether the business is temporarily closed.
   */
  temporarilyClosed?: boolean;
  /**
   * The place ID of the business.
   */
  placeId?: string;
  /**
   * The categories the business belongs to.
   */
  categories?: string[];
  /**
   * The number of reviews the business has.
   */
  reviewsCount?: number;
  /**
   * The opening hours of the business.
   */
  openingHours?: { day?: string; hours?: string }[]; 
  /**
   * Tags associated with the business.
   */
  placesTags?: string[];
  /**
   * Additional information about the business.
   */
  additionalInfo?: any; 
  /**
   * The URL of the business.
   */
  url?: string;
  /**
   * The image URL of the business.
   */
  imageUrl?: string;
  /**
   * The website of the business.
   */
  website?: string;
  /**
   * The description of the business.
   */
  description?: string;
  /**
   * The menu of the business.
   */
  menu?: string;
  /**
   * The reviews of the business.
   */
  reviews?: JsonReviewDetail[]; 
  /**
   * The image URLs of the business (gallery).
   */
  imageUrls?: string[]; 
}

/**
 * Interface for the report generated by the import process.
 * Tracks the number of items processed, imported, and any errors encountered.
 */
interface ImportReport {
  /**
   * The total number of items processed.
   */
  totalProcessed: number;
  /**
   * The number of listings imported.
   */
  listingsImported: number; 
  /**
   * The number of categories processed.
   */
  categoriesProcessed: number;
  /**
   * The number of opening hours processed.
   */
  openingHoursProcessed: number;
  /**
   * The number of photos imported.
   */
  photosImported: number; 
  /**
   * The number of reviews imported.
   */
  reviewsImported: number; 
  /**
   * An array of error messages encountered during the import process.
   */
  errors: string[];
}

/**
 * API handler for importing business listings from an external JSON URL (e.g., Apify dataset).
 * Requires ADMIN privileges.
 * This endpoint fetches data from the provided URL, processes each listing, and attempts to
 * create or update corresponding records in the database for Businesses, ListingBusinesses,
 * Categories, Reviews, and Photos.
 *
 * @param {NextApiRequest} req The Next.js API request object.
 * @param {NextApiResponse} res The Next.js API response object.
 *
 * @route POST /api/admin/import-listings
 * @description Imports business listings from a JSON file hosted at a given URL.
 * @header Content-Type application/json
 * @bodyParam {string} url - The URL of the JSON file containing an array of listings to import.
 * @returns {Promise<void>} Responds with an import report detailing successes and failures.
 * @successResponse 200 OK - { message: string, report: ImportReport } Import process completed.
 * @errorResponse 400 Bad Request - If the JSON URL is missing or the fetched data is not an array.
 * @errorResponse 401 Unauthorized - If the user is not an ADMIN.
 * @errorResponse 405 Method Not Allowed - If the request method is not POST.
 * @errorResponse 500 Internal Server Error - If a critical error occurs during the import process. The report may contain partial information.
 */
export default async function handler(req: NextApiRequest, res: NextApiResponse) {
  // --- BEGIN CASCADE DEBUG LOGS ---
  console.log(`[IMPORT-LISTINGS-API] Handler invoked. Timestamp: ${new Date().toISOString()}`);
  console.log(`[IMPORT-LISTINGS-API] Request Method: ${req.method}`);
  
  console.log('[IMPORT-LISTINGS-API] Attempting to get session...');
  const session = await getServerSession(req, res, authOptions);

  if (session && session.user) {
    console.log('[IMPORT-LISTINGS-API] Session retrieved. User:', JSON.stringify(session.user, null, 2));
  } else if (session) {
    console.log('[IMPORT-LISTINGS-API] Session retrieved, but no session.user object found.');
  } else {
    console.log('[IMPORT-LISTINGS-API] No session found by getServerSession.');
  }
  // --- END CASCADE DEBUG LOGS ---

  if (req.method !== 'POST') {
    console.log(`[IMPORT-LISTINGS-API] Incorrect method (${req.method}). Responding with 405 Method Not Allowed.`);
    return res.status(405).json({ message: 'Method Not Allowed' });
  }

  // --- BEGIN CASCADE DEBUG LOGS (POST block) ---
  console.log('[IMPORT-LISTINGS-API] Method is POST. Proceeding with import.');
  // --- END CASCADE DEBUG LOGS (POST block) ---

  // Restore authentication check
  // Ensures that only authenticated admin users can trigger the import.
  if (!session || !session.user || session.user.role !== UserRole.ADMIN) { 
    console.log('[IMPORT-LISTINGS-API] Authorization failed. No session, no user, or user is not ADMIN.');
    return res.status(401).json({ message: 'Unauthorized: Admin access required.' });
  }

  // --- BEGIN CASCADE DEBUG LOGS (Auth success block) ---
  console.log('[IMPORT-LISTINGS-API] Authentication successful. User is ADMIN. Proceeding with import logic.');
  // --- END CASCADE DEBUG LOGS (Auth success block) ---

  const { url: jsonUrl } = req.body;
  if (!jsonUrl || typeof jsonUrl !== 'string') {
    console.log('[IMPORT-LISTINGS-API] JSON URL is missing or not a string.');
    return res.status(400).json({ message: 'JSON URL is required' });
  }

  // Use the current authenticated admin's user ID for associating created businesses.
  const currentAdminUserId = session.user.id; 
  if (!currentAdminUserId) {
    // This should ideally not happen if session.user.id is guaranteed by types
    console.error('[IMPORT-LISTINGS-API] Critical error: Admin User ID not found in session.');
    return res.status(500).json({ message: 'Critical error: Admin User ID not found in session.' });
  }
  console.log(`[IMPORT-LISTINGS-API] Using current admin user ID: ${currentAdminUserId} for import.`);

  const report: ImportReport = {
    totalProcessed: 0,
    listingsImported: 0, 
    categoriesProcessed: 0,
    openingHoursProcessed: 0, // Note: Opening hours from Apify are not currently processed into DB.
    photosImported: 0, 
    reviewsImported: 0, 
    errors: [],
  };

  console.log(`[IMPORT-LISTINGS-API] Starting fetch from URL: ${jsonUrl}`);
  try {
    const fetchRes = await fetch(jsonUrl);
    if (!fetchRes.ok) {
      let errorBody = '';
      try {
        errorBody = await fetchRes.text();
      } catch {}
      const fetchErrorMsg = `Failed to fetch data from URL: ${fetchRes.status} ${fetchRes.statusText}. Response body: ${errorBody}`;
      console.error(`[IMPORT-LISTINGS-API] Error fetching URL: ${fetchErrorMsg}`);
      throw new Error(fetchErrorMsg);
    }
    // Assuming the fetched data is an array of ApifyListingItem
    const listingsData = (await fetchRes.json()) as ApifyListingItem[];
    console.log(`[IMPORT-LISTINGS-API] Successfully fetched and parsed JSON. Number of items: ${listingsData.length}`);

    if (!Array.isArray(listingsData)) {
        const typeErrorMsg = 'Fetched data is not an array. Please ensure the URL points to a JSON array of listings.';
        console.error(`[IMPORT-LISTINGS-API] Data type error: ${typeErrorMsg}`);
        throw new Error(typeErrorMsg);
    }

    // Iterate through each listing item from the fetched JSON data.
    for (const item of listingsData) {
      report.totalProcessed++;
      // Basic validation: skip items without a title.
      if (!item.title || item.title.trim() === '') {
        console.log(`[IMPORT-LISTINGS-API] Skipping item due to missing title: ${JSON.stringify(item).substring(0,100)}`);
        report.errors.push(`Skipping item due to missing title: ${JSON.stringify(item).substring(0,100)}`);
        continue;
      }

      // 1. Create a new Business record for this listing.
      // This represents the overarching business entity.
      let newBusiness;
      try {
        newBusiness = await prisma.business.create({
          data: {
            name: item.title, // Use listing title as business name for simplicity.
            user_id: parseInt(currentAdminUserId, 10), // Associate with the importing admin.
            description: item.description || 'Imported business', // Default description if not provided.
          },
        });
        console.log(`[IMPORT-LISTINGS-API] Created new Business ID: ${newBusiness.business_id} for listing: ${item.title}`);
      } catch (e: any) {
        const businessErrorMsg = `Error creating Business for listing '${item.title}': ${e.message}`;
        console.error(`[IMPORT-LISTINGS-API] ${businessErrorMsg}`);
        report.errors.push(businessErrorMsg);
        continue; // Skip to next item if Business creation fails.
      }

      // Generate a unique slug for the ListingBusiness.
      const generatedSlug = await generateUniqueSlug(item.title, prisma); 
      console.log(`[IMPORT-LISTINGS-API] Generated slug: ${generatedSlug} for title: ${item.title}`);

      // Prepare data for ListingBusiness creation/update.
      const listingBusinessInput: Prisma.ListingBusinessCreateInput = {
        business: { 
          connect: { 
            business_id: newBusiness.business_id 
          }
        },
        title: item.title, 
        slug: generatedSlug, 
        place_id: item.placeId, // Used for upserting to avoid duplicates.
        address: item.address, 
        street: item.street, 
        city: item.city,
        state: item.state, 
        postal_code: item.postalCode,
        country_code: item.countryCode,
        latitude: item.location?.lat ? new Decimal(item.location.lat) : undefined,
        longitude: item.location?.lng ? new Decimal(item.location.lng) : undefined,
        phone: item.phone,
        website: item.website, 
        url: item.url, 
        description: item.description,
        reviews_count: item.reviewsCount || 0,
        price_range: item.price,
        permanently_closed: item.permanentlyClosed || false,
        temporarily_closed: item.temporarilyClosed || false,
        image_url: item.imageUrl, 
        menu_url: item.menu,
        isFeatured: false, 
        category_name: item.categoryName, 
      };

      if (item.imageUrl) {
        report.photosImported++; // Count the main image_url if present.
      }

      // Prepare data for related ListingBusinessCategory records.
      // Categories are connected or created based on their slug.
      const listingBusinessCategoryInputs: Prisma.ListingBusinessCategoryCreateWithoutBusinessInput[] = [];
      const itemCategories = item.categories || (item.categoryName ? [item.categoryName] : []);
      
      for (const catName of itemCategories) {
        if (catName.trim()) {
          const categorySlug = slugify(catName.trim(), { lower: true, strict: true });
          listingBusinessCategoryInputs.push({
            category: { 
              connectOrCreate: {
                where: { slug: categorySlug }, 
                create: { category_name: catName.trim(), slug: categorySlug }, 
              }
            }
          });
          report.categoriesProcessed++;
        }
      }
      
      // Add categories to the ListingBusiness input if any were processed.
      if (listingBusinessCategoryInputs.length > 0) {
        listingBusinessInput.categories = {
          create: listingBusinessCategoryInputs
        };
      }

      // Prepare data for related ListingReview records.
      let listingReviewInputs: Prisma.ListingReviewCreateManyListingBusinessInput[] = [];
      if (item.reviews && Array.isArray(item.reviews)) {
        listingReviewInputs = item.reviews.map((review: any) => ({
          reviewer_name: review.name,
          review_text: review.text,
          rating: review.stars !== undefined ? new Decimal(review.stars) : undefined, 
          published_at_date: review.publishedAtDate ? new Date(review.publishedAtDate) : undefined,
          // Note: reviewImageUrls, responseFromOwnerText, etc., from JsonReviewDetail are not currently mapped.
        }));
        report.reviewsImported += listingReviewInputs.length; // Increment by number of reviews processed.
      }

      // Consolidate all data for ListingBusiness upsert.
      const listingDataToBeSaved: Prisma.ListingBusinessCreateInput = {
        ...listingBusinessInput,
        // Ensure categories and reviews are structured correctly for Prisma create/upsert.
        categories: listingBusinessCategoryInputs.length > 0 ? { create: listingBusinessCategoryInputs } : undefined,
        reviews: listingReviewInputs.length > 0 ? { createMany: { data: listingReviewInputs } } : undefined,
        // ImageUrls (gallery) will be handled after listing creation/upsertion to get listing_business_id.
      };

      console.log(`[IMPORT-LISTINGS-API] Attempting to upsert ListingBusiness for placeId: ${item.placeId}`);
      // Upsert ListingBusiness: update if placeId exists, otherwise create.
      const upsertedListing = await prisma.listingBusiness.upsert({
        where: { place_id: item.placeId }, 
        update: listingDataToBeSaved, 
        create: listingDataToBeSaved,
      });
      report.listingsImported++;
      console.log(`[IMPORT-LISTINGS-API] Successfully upserted ListingBusiness ID: ${upsertedListing.listing_business_id} for: ${item.title}`);

      // 2. Handle ListingImageUrls (gallery images) after ListingBusiness is created/upserted.
      // This requires the listing_business_id from the upsertedListing.
      if (item.imageUrls && Array.isArray(item.imageUrls) && item.imageUrls.length > 0) {
        console.log(`[IMPORT-LISTINGS-API] Found ${item.imageUrls.length} gallery images for listing ID: ${upsertedListing.listing_business_id}`);
        for (const imageUrl of item.imageUrls) {
          if (imageUrl && typeof imageUrl === 'string') {
            try {
              await prisma.listingImageUrl.create({
                data: {
                  listing_business_id: upsertedListing.listing_business_id,
                  url: imageUrl,
                  // description: can be added if your Apify data provides it per image.
                }
              });
              report.photosImported++; // Increment for each gallery image successfully added.
              console.log(`[IMPORT-LISTINGS-API] Added gallery image: ${imageUrl} to listing ID: ${upsertedListing.listing_business_id}`);
            } catch (imgErr: any) {
              const imgErrorMsg = `Error adding gallery image ${imageUrl} for listing ID ${upsertedListing.listing_business_id}: ${imgErr.message}`;
              console.error(`[IMPORT-LISTINGS-API] ${imgErrorMsg}`);
              report.errors.push(imgErrorMsg);
            }
          }
        }
      } else if (item.imageUrl && !item.imageUrls) { 
          // The main item.imageUrl is already part of listingBusinessInput.image_url
          // report.photosImported was incremented earlier if item.imageUrl existed.
          // If item.imageUrls is an empty array, this block won't be hit.
      }

    }

    console.log('[IMPORT-LISTINGS-API] Import process finished. Final report:', JSON.stringify(report, null, 2));
    res.status(200).json({ message: 'Import process completed.', report });
  } catch (error: any) {
    console.error('[IMPORT-LISTINGS-API] Critical error during import process:', error.message, error.stack);
    report.errors.push(`A critical error occurred: ${error.message}`);
    res.status(500).json({ message: `An error occurred: ${error.message}`, report });
  }
}
